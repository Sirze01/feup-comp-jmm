PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;
TOKENS_ARE_NODES=false;

SKIP : " " | "\t" | "\r" | "\n"
    | < MULTI_LINE_COMMENT : "/*" (~["*"])* "*" (~["*","/"] (~["*"])* "*" | "*")* "/" >
    | < SINGLE_LINE_COMMENT : "//" (~["\n"])* >
;

TOKEN :
        < IMPORT : "import" >
        | <CLASS: "class" >
        | <VOID: "void" >
        | <MAIN: "main" >

        | <EXTENDS: "extends" >
        | <PUBLIC: "public" >
        | <STATIC: "static" >
        | <RETURN: "return" >
        | <THIS: "this" >
        | <NEW: "new" >

	    | <INTEGERLITERAL: (<DIGIT>)+ >
        | <DIGIT: ["0" - "9"] >

        | <INT: "int" >
        | <BOOLEAN: "boolean" >
        | <STRING: "String" >

        | <OPENBRACKET: "{" >
        | <CLOSEBRACKET: "}" >
        | <OPENPAREN: "(" >
        | <CLOSEPAREN: ")" >
        | <OPENARRAY: "[" >
        | <CLOSEARRAY: "]" >
        | <SEMICOLON: ";" >
        | <COLON: ":" >
        | <COMMA: "," >
        | <DOT: "." >
        | <LENGTH: "length" >

        | <TRUE: "true" >
        | <FALSE: "false" >
        | <AND: "&&" >
        | <LESS: "<" >
        | <ADD: "+" >
        | <SUB: "-" >
        | <MULT: "*" >
        | <DIV: "/" >
        | <NOT: "!" >
        | <EQUALS: "=" >

        | <IF: "if" >
        | <ELSE: "else" >
        | <WHILE: "while" >

        | <IDENTIFIER: (<LETTER> | <DOLLAR> | <UNDERSCORE> ) (<LETTER> | <DOLLAR> | <UNDERSCORE> | <DIGIT>)* >
        | <LETTER: (<LOWERCASE> | <UPPERCASE>) >
        | <LOWERCASE: ["a"-"z"] >
        | <UPPERCASE: ["A"-"Z"] >
        | <DOLLAR: "$" >
        | <UNDERSCORE: "_" >
;

Program :
    (ImportDeclaration)* ClassDeclaration <EOF> ;

// Declarations

ImportDeclaration :
    <IMPORT> <IDENTIFIER> (<DOT> < IDENTIFIER>)* <SEMICOLON>
;

ClassDeclaration :
    <CLASS> <IDENTIFIER> (<EXTENDS> <IDENTIFIER> )?
    <OPENBRACKET>
        (VarDeclaration)*
        (MethodDeclaration)*
    <CLOSEBRACKET>
;

VarDeclaration :
    Type <IDENTIFIER> <SEMICOLON>
;

MethodDeclaration :
    <PUBLIC> (InstanceMethod | MainMethod)
;

InstanceMethod :
    MethodHeader
    <OPENPAREN> MethodArguments <CLOSEPAREN>
    <OPENBRACKET> MethodBody ReturnExpression <CLOSEBRACKET>
;

MainMethod:
    MethodHeaderMain
    <OPENPAREN> MethodArgumentsMain <CLOSEPAREN>
    <OPENBRACKET> MethodBody <CLOSEBRACKET>
;

MethodHeader :
     Type <IDENTIFIER>
;

MethodHeaderMain :
    <STATIC> <VOID> <MAIN>
;

MethodArguments :
    (Type <IDENTIFIER> (<COMMA> Type <IDENTIFIER>)*)?
;

MethodArgumentsMain :
    <STRING> <OPENARRAY> <CLOSEARRAY> <IDENTIFIER>
;

MethodBody :
    (SCAN 2 VarDeclaration)* (Statement)*
;

ReturnExpression :
    <RETURN> Expression <SEMICOLON>
;

Type :
    <INT> (<OPENARRAY> <CLOSEARRAY>)?
    | <BOOLEAN>
    | <STRING>
    | <IDENTIFIER>
;

// Statements

Statement :
    BracketStatement
    | IfStatement
    | WhileStatement
    | (SCAN 2 AssignmentExpression | Expression <SEMICOLON>)
;

BracketStatement :
    <OPENBRACKET> (Statement)* <CLOSEBRACKET>
;

IfStatement :
    <IF> ParenthesisExpression Statement <ELSE> Statement
;

WhileStatement :
    <WHILE> ParenthesisExpression Statement
;

AssignmentExpression :
    <IDENTIFIER> (IdAssignmentExpression | ArrayAssignmentExpression) <SEMICOLON>
;

IdAssignmentExpression :
     <EQUALS> Expression
;

ArrayAssignmentExpression :
    ArrayExpression <EQUALS> Expression
;

// Expressions

Expression #void:
    AndExpression
;

AndExpression #void:
    LessExpression ((<AND> LessExpression) ({jjtThis.put("op", "And"); }) #BinOp(2))*
;

LessExpression #void:
    AddSubExpression ((<LESS> AddSubExpression) ({jjtThis.put("op", "Less"); }) #BinOp(2))*
;

AddSubExpression #void:
    MultDivExpression ((<ADD> MultDivExpression) ({jjtThis.put("op", "Add"); }) #BinOp(2)
    | (<SUB> MultDivExpression) ({jjtThis.put("op", "Sub"); }) #BinOp(2))*
;

MultDivExpression #void:
    NotExpression ((<MULT> NotExpression) ({jjtThis.put("op", "Mult"); }) #BinOp(2)
     | (<DIV> NotExpression) ({jjtThis.put("op", "Div"); }) #BinOp(2))*
;

NotExpression #void:
    (<NOT> NotExpression) ({jjtThis.put("op", "Not"); }) #UnaryOp(1)
    | RecursiveArrayExpression
;

RecursiveArrayExpression #void:
    FinalTerms (ArrayExpression #ArrayExpression(2) | DotExpression)*
;

ArrayExpression #void:
    <OPENARRAY> Expression <CLOSEARRAY>
;

DotExpression :
    <DOT> ((<LENGTH>) | CallExpression)
;

CallExpression :
    <IDENTIFIER> <OPENPAREN> (Expression (<COMMA> Expression)*)? <CLOSEPAREN>
;

FinalTerms #void:
    <INTEGERLITERAL> ({jjtThis.put("value", lastConsumedToken.getImage()); }{jjtThis.put("type", "Int"); }) #Literal
    | <TRUE> ({jjtThis.put("value", lastConsumedToken.getImage()); }{jjtThis.put("type", "Boolean"); }) #Literal
    | <FALSE> ({jjtThis.put("value", lastConsumedToken.getImage()); }{jjtThis.put("type", "Boolean"); }) #Literal
    | <IDENTIFIER> ({jjtThis.put("name", lastConsumedToken.getImage()); }) #ID
    | <THIS> ({jjtThis.put("value", lastConsumedToken.getImage()); }{jjtThis.put("type", "Object"); }) #Literal
    | NewExpression
    | ParenthesisExpression
;

NewExpression #void:
    <NEW> (
    ( (<INT> ArrayExpression #ArrayExpression ) ({jjtThis.put("type", "IntArray");})) #New
    | ( ( (<IDENTIFIER> ({jjtThis.put("value", lastConsumedToken.getImage()); }) #ID) <OPENPAREN> <CLOSEPAREN>)
            ({jjtThis.put("type", "Class");})) #New
    )
;

ParenthesisExpression :
    <OPENPAREN> Expression <CLOSEPAREN>
;

// Injections for the implementation of JmmNode
// Since this is injected into BaseNode, it affects only non-terminals
INJECT BaseNode :
        import pt.up.fe.comp.jmm.ast.JmmNode;
        import pt.up.fe.comp.jmm.ast.AJmmNode;
        import pt.up.fe.specs.util.SpecsCollections;
        extends AJmmNode
{
    @Override
    public List<JmmNode> getChildren() {

        return SpecsCollections.cast(children(), JmmNode.class);
    }

    @Override
    public void add(JmmNode child, int index) {

        if (child instanceof Node) {

            addChild(index, (Node) child);
        } else {

            throw new RuntimeException("Node " + child + " is not a Node.");
        }

    }
}