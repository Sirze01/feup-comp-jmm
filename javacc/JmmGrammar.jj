PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;
TOKENS_ARE_NODES=false;

SKIP : " " | "\t" | "\r" | "\n"
    | < MULTI_LINE_COMMENT : "/*" (~["*"])* "*" (~["*","/"] (~["*"])* "*" | "*")* "/" >
    | < SINGLE_LINE_COMMENT : "//" (~["\n"])* >
;

TOKEN :
        < IMPORT : "import" >
        | <CLASS: "class" >
        | <VOID: "void" >
        | <MAIN: "main" >

        | <EXTENDS: "extends" >
        | <PUBLIC: "public" >
        | <STATIC: "static" >
        | <RETURN: "return" >
        | <THIS: "this" >
        | <NEW: "new" >

	    | <INTEGERLITERAL: (<DIGIT>)+ >
        | <DIGIT: ["0" - "9"] >

        | <INT: "int" >
        | <BOOLEAN: "boolean" >
        | <STRING: "String" >

        | <OPENBRACKET: "{" >
        | <CLOSEBRACKET: "}" >
        | <OPENPAREN: "(" >
        | <CLOSEPAREN: ")" >
        | <OPENARRAY: "[" >
        | <CLOSEARRAY: "]" >
        | <SEMICOLON: ";" >
        | <COLON: ":" >
        | <COMMA: "," >
        | <DOT: "." >
        | <LENGTH: "length" >

        | <TRUE: "true" >
        | <FALSE: "false" >
        | <AND: "&&" >
        | <LESS: "<" >
        | <ADD: "+" >
        | <SUB: "-" >
        | <MULT: "*" >
        | <DIV: "/" >
        | <NOT: "!" >
        | <EQUALS: "=" >

        | <IF: "if" >
        | <ELSE: "else" >
        | <WHILE: "while" >

        | <IDENTIFIER: (<LETTER> | <DOLLAR> | <UNDERSCORE> ) (<LETTER> | <DOLLAR> | <UNDERSCORE> | <DIGIT>)* >
        | <LETTER: (<LOWERCASE> | <UPPERCASE>) >
        | <LOWERCASE: ["a"-"z"] >
        | <UPPERCASE: ["A"-"Z"] >
        | <DOLLAR: "$" >
        | <UNDERSCORE: "_" >
;

Program :
    (ImportDeclaration)* ClassDeclaration <EOF> ;

// Declarations

ImportDeclaration :
    <IMPORT> <IDENTIFIER> (<DOT> < IDENTIFIER>)* <SEMICOLON>
;

ClassDeclaration :
    <CLASS> <IDENTIFIER> (<EXTENDS> <IDENTIFIER> )?
    <OPENBRACKET>
        (VarDeclaration)*
        (MethodDeclaration)*
    <CLOSEBRACKET>
;

VarDeclaration :
    Type <IDENTIFIER> <SEMICOLON>
;

MethodDeclaration :
    <PUBLIC> (InstanceMethod | MainMethod)
;

InstanceMethod :
    MethodHeader
    <OPENPAREN> MethodArguments <CLOSEPAREN>
    <OPENBRACKET> MethodBody ReturnExpression <CLOSEBRACKET>
;

MainMethod:
    MethodHeaderMain
    <OPENPAREN> MethodArgumentsMain <CLOSEPAREN>
    <OPENBRACKET> MethodBody <CLOSEBRACKET>
;

MethodHeader :
     Type <IDENTIFIER>
;

MethodHeaderMain :
    <STATIC> <VOID> <MAIN>
;

MethodArguments :
    (Type <IDENTIFIER> (<COMMA> Type <IDENTIFIER>)*)?
;

MethodArgumentsMain :
    <STRING> <OPENARRAY> <CLOSEARRAY> <IDENTIFIER>
;

MethodBody :
    (SCAN 2 VarDeclaration)* (Statement)*
;

ReturnExpression :
    <RETURN> Expression <SEMICOLON>
;

Type :
    <INT> (<OPENARRAY> <CLOSEARRAY>)?
    | <BOOLEAN>
    | <STRING>
    | <IDENTIFIER>
;

// Statements

Statement :
    BracketStatement
    | IfStatement
    | WhileStatement
    | (SCAN 2 AssignmentExpression | Expression <SEMICOLON>)
;

BracketStatement :
    <OPENBRACKET> (Statement)* <CLOSEBRACKET>
;

IfStatement :
    <IF> ParenthesisExpression Statement <ELSE> Statement
;

WhileStatement :
    <WHILE> ParenthesisExpression Statement
;

AssignmentExpression :
    <IDENTIFIER> (IdAssignmentExpression | ArrayAssignmentExpression) <SEMICOLON>
;

IdAssignmentExpression :
     <EQUALS> Expression
;

ArrayAssignmentExpression :
    ArrayExpression <EQUALS> Expression
;

// Expressions

Expression :
    AndExpression
;

AndExpression :
    LessExpression (<AND> LessExpression)*
;

LessExpression :
    AddSubExpression (<LESS> AddSubExpression)*
;

AddSubExpression :
    MultDivExpression ((<ADD> MultDivExpression | <SUB> MultDivExpression))*
;

MultDivExpression :
    NotExpression ((<MULT> NotExpression | <DIV> NotExpression))*
;

NotExpression :
    <NOT> NotExpression | RecursiveArrayExpression
;

RecursiveArrayExpression :
    FinalTerms (ArrayExpression | DotExpression)*
;

ArrayExpression :
    <OPENARRAY> Expression <CLOSEARRAY>
;

DotExpression :
    <DOT> (<LENGTH> | CallExpression)
;

CallExpression :
    <IDENTIFIER> <OPENPAREN> (Expression (<COMMA> Expression)*)? <CLOSEPAREN>
;

FinalTerms :
    <INTEGERLITERAL>
    | <TRUE>
    | <FALSE>
    | <IDENTIFIER>
    | <THIS>
    | NewExpression
    | ParenthesisExpression
;

NewExpression :
    <NEW> (<INT> ArrayExpression | <IDENTIFIER> <OPENPAREN> <CLOSEPAREN>)
;

ParenthesisExpression :
    <OPENPAREN> Expression <CLOSEPAREN>
;
