PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;

SKIP : " " | "\t" | "\r" | "\n";

TOKEN :
        < IMPORT : "import" >
        | <CLASS: "class" >
        | <VOID: "void" >
        | <MAIN: "main" >

        | <EXTENDS: "extends" >
        | <PUBLIC: "public" >
        | <STATIC: "static" >
        | <RETURN: "return" >
        | <THIS: "this" >
        | <NEW: "new" >

	    | <INTEGERLITERAL: (<DIGIT>)+ >
        | <DIGIT: ["0" - "9"] >

        | <INT: "int" >
        | <BOOLEAN: "boolean" >
        | <STRING: "String" >

        | <OPENBRACKET: "{" >
        | <CLOSEBRACKET: "}" >
        | <OPENPAREN: "(" >
        | <CLOSEPAREN: ")" >
        | <OPENARRAY: "[" >
        | <CLOSEARRAY: "]" >
        | <SEMICOLON: ";" >
        | <COLON: ":" >
        | <COMMA: "," >
        | <DOT: "." >
        | <LENGTH: "length" >

        | <TRUE: "true" >
        | <FALSE: "false" >
        | <AND: "&&" >
        | <LESS: "<" >
        | <ADD: "+" >
        | <SUB: "-" >
        | <MULT: "*" >
        | <DIV: "/" >
        | <NOT: "!" >
        | <EQUALS: "=" >

        | <IF: "if" >
        | <ELSE: "else" >
        | <WHILE: "while" >

        | <IDENTIFIER: (<LETTER> | <DOLLAR> | <UNDERSCORE> ) (<LETTER> | <DOLLAR> | <UNDERSCORE> | <DIGIT>)* >
        | <LETTER: (<LOWERCASE> | <UPPERCASE>) >
        | <LOWERCASE: ["a"-"z"] >
        | <UPPERCASE: ["A"-"Z"] >
        | <DOLLAR: "$" >
        | <UNDERSCORE: "_" >
;

Program :
    ImportDeclaration ClassDeclaration <EOF> ;

ImportDeclaration :
    (<IMPORT> <IDENTIFIER>
        ( <DOT> < IDENTIFIER> )*
    <SEMICOLON>)*
;

ClassDeclaration :
    <CLASS> <IDENTIFIER>
    (
        <EXTENDS> <IDENTIFIER>
    )?
    <OPENBRACKET>
        (VarDeclaration)*
        (MethodDeclaration)*
    <CLOSEBRACKET>
;

VarDeclaration :
    Type <IDENTIFIER> <SEMICOLON>
;

MethodDeclaration :
    <PUBLIC> Type <IDENTIFIER>
    <OPENPAREN>
        (
            Type <IDENTIFIER>
            (<COMMA> Type <IDENTIFIER>)*
        )?
    <CLOSEPAREN>
    <OPENBRACKET>
        (VarDeclaration)*
        (Statement)*
        <RETURN> Expression <SEMICOLON>
    <CLOSEBRACKET>

    |

    <PUBLIC> <STATIC> <VOID> <MAIN>
    <OPENPAREN>
        <STRING> <OPENARRAY> <CLOSEARRAY>
        <IDENTIFIER>
    <CLOSEPAREN>
    <OPENBRACKET>
        (VarDeclaration)*
        (Statement)*
    <CLOSEBRACKET>
;

Type :
    <INT> <OPENARRAY> <CLOSEARRAY>
    | <BOOLEAN>
    | <INT>
    | <STRING>
    | <IDENTIFIER>
;

Statement :
    <OPENBRACKET> Statement <CLOSEBRACKET>

    | <IF> <OPENPAREN> Expression <CLOSEPAREN> Statement <ELSE> Statement

    | <WHILE> <OPENPAREN> Expression <CLOSEPAREN> Statement

    | Expression <SEMICOLON>

    | <IDENTIFIER> <EQUALS> Expression <SEMICOLON>

    | <IDENTIFIER> <OPENARRAY> Expression <CLOSEARRAY> <EQUALS> Expression <SEMICOLON>
;

Expression :
    Expression (<AND> | <LESS> | <ADD> | <SUB> | <MULT> | <DIV>) Expression

    | Expression <OPENARRAY> Expression <CLOSEARRAY>

    | Expression <DOT> <LENGTH>

    | Expression <DOT> <IDENTIFIER>
      <OPENPAREN>
        (
            Expression (<COMMA> Expression)*
        )?
      <CLOSEPAREN>

    | <INTEGERLITERAL>

    | <TRUE>

    | <FALSE>

    | <IDENTIFIER>

    | <THIS>

    | <NEW> <INT> <OPENARRAY> Expression <CLOSEARRAY>

    | <NEW> <IDENTIFIER> <OPENPAREN> <CLOSEPAREN>

    | <NOT> Expression

    | <OPENPAREN> Expression <CLOSEPAREN>

;

Start : AdditiveExpression <EOF> ;

AdditiveExpression :
	MultiplicativeExpression
	(
		(< ADD > | < SUB >)
		MultiplicativeExpression
	)?
;

MultiplicativeExpression :
	Factor
	(
		(< MULT > | < DIV >)
		Factor
	)?
;

Factor :
	< INTEGERLITERAL > |
	< SUB > Factor |
	< OPENPAREN > AdditiveExpression < CLOSEPAREN >
;
